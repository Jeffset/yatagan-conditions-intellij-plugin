label.yatagan.conditions.file=Yatagan condition expression

settings.yatagan.conditions.color.access=Access operator
settings.yatagan.conditions.color.bad=Bad character
settings.yatagan.conditions.color.dot=Dot
settings.yatagan.conditions.color.method=Condition path member (method)
settings.yatagan.conditions.color.field=Condition path member (field)
settings.yatagan.conditions.color.operators=Logical operators
settings.yatagan.conditions.color.parentheses=Parentheses
settings.yatagan.conditions.color.qualifier=Condition qualifier (provider)
settings.yatagan.conditions.color.reference=Feature reference
settings.yatagan.conditions.color.unresolved=Unresolved

settings.yatagan.conditions.name=Yatagan Conditions

warning.yatagan.conditions.invalid.context=Unable to find an enclosing Yatagan annotation \
  (@Condition/@ConditionExpression). This language is only supported while injected into such an annotation, \
  no semantic highlighting is currently possible.

warning.yatagan.conditions.injecting.object=It seems that Kotlin object `{0}` is being used as a non-static \
  condition provider here. That is very likely an error. "INSTANCE" should be added as a first member of the \
  condition access path to use the object from the static context, and not try to resolve its instance from in \
  the graph.

error.yatagan.conditions.invalid.legacy=Legacy @Condition only supports a single unqualified boolean variable.
error.yatagan.conditions.invalid.boolean=The end of the condition access path `{0}` does not evaluate to boolean. \
  Got `{1}` instead.
error.yatagan.conditions.invalid.parameters=A method with parameters can not be used in the condition path: `{0}`.
error.yatagan.conditions.unresolved.qualifier=Unresolved qualifier: `{0}`.
error.yatagan.conditions.unresolved.reference=Unresolved feature reference: `{0}`.
error.yatagan.conditions.unresolved.member=Unresolved method/field: `{0}`.
error.yatagan.conditions.invalid.inaccessible=The method/field should be public (or internal): `{0}`.
